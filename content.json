{"meta":{"title":"Noteligible' Blog","subtitle":null,"description":"��Զ��Ҫ����","author":"Noteligible","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-06-19T01:49:00.000Z","updated":"2019-06-19T01:49:00.970Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-06-19T01:49:28.000Z","updated":"2019-06-19T07:57:33.092Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-19T01:49:16.000Z","updated":"2019-06-19T08:30:29.290Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MyBatis 概述","slug":"MyBatis 概述","date":"2019-06-19T01:24:45.000Z","updated":"2019-06-19T16:43:11.958Z","comments":true,"path":"2019/06/19/MyBatis 概述/","link":"","permalink":"http://yoursite.com/2019/06/19/MyBatis 概述/","excerpt":"","text":"本文对 MyBatis 做一个简单介绍，包括框架原理，执行过程，DAO开发方法，输入输出映射及动态sql。 MyBatis介绍MyBatis 原本是 apache 的一个开源项目 iBatis, 2010年这个项目由 apache software foundation 迁移到了 google code，并且改名为MyBatis。2013年11月迁移到 Github下（https://github.com/mybatis/mybatis-3/releases）。 MyBatis 是一个优秀的持久层框架，它对 JDBC 的操作数据库的过程进行封装，使开发者只需要关注 sql 本身，而不需要花费精力去处理例如注册驱动、创建 connection、创建 statement、手动设置参数、结果集检索等 JDBC 繁杂的过程代码。 Mybatis 通过 xml 或 注解 的方式将要执行的各种 statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过 java 对象和 statement中 的 sql 进行映射生成最终执行的 sql 语句，最后由 MyBatis 框架执行 sql 并将结果集映射成 Java 对象并返回。 MyBatis 架构1、MyBatis 配置文件。 SqlMapConfig.xml：此文件作为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息。 mapper.xml：sql映射文件，配置了操作数据库的 sql 语句，此文件需要在 SqlMapConfig.xml 中加载。 2、通过 MyBatis 环境等配置信息构造 SqlSessionFactory（会话工厂）。 3、由会话工厂创建 SqlSession（会话），操作数据库需要通过 SqlSession 进行。 4、MyBatis 底层自定义了 Executor 执行器接口操作数据库，Executor 接口有两个实现，一个是基本执行器、一个是缓存执行器。 5、Mapped Statement 也是 MyBatis 一个底层封装对象，它包装了 MyBatis 配置信息及 sql 映射信息等，mapper.xml 文件中一个 sql 对应一个 Mapped Statement 对象，sql 的 id 即是 Mapped statement 的 id。 6、Mapped Statement 对 sql 执行输入参数进行定义，包括 HashMap、基本类型、pojo，Executor 通过 Mapped Statement 在执行 sql 前将输入的 Java 对象映射至 sql 中，输入参数映射就是 JDBC 编程中对 preparedStatement 设置参数。 7、Mapped Statement 对 sql 执行输出结果进行定义，包括 HashMap、基本类型、pojo，Executor 通过 Mapped Statement 在执行 sql 后将输出结果映射至 Java 对象中，输出结果映射过程相当于 JDBC 编程中对结果的解析处理过程。 三、MyBatis 运行过程1、配置 MyBatis 的配置文件：mybatis-config.xml（名称不固定）。 2、通过配置文件，加载 MyBatis 运行环境，创建 SqlSessionFactory 会话工厂（SqlSessionFactory 在实际使用时按单例方式）。 3、通过 SqlSessionFactory 创建 SqlSession。SqlSession 是一个面向用户接口（提供操作数据库方法），实现对象是线程不安全的，建议 SqlSession 的应用场合在方法体内。 4、调用 SqlSession 的方法去操作数据。如果需要提交事务，需要执行SqlSession的commit()方法。 5、释放资源，关闭 SqlSession。 MyBatis 开发 DAO 的方法使用 MyBatis 开发 Dao 通常有两个方法：原始 Dao 、Mapper 动态代理开发（官方推荐）。 原始 DAO需要程序员编写 DAO 接口及其实现类； 需要在 DAO 接口的实现类上注入 sqlSessionFactory，创建 sqlSessionFactory 时需要读取 mapper.xml 到内存； 通过创建 sqlSession 对象来调用 mapper 中的 sql 语句，在操作结束后需要手工进行提交，释放资源，返回结果； 存在的问题： Dao 实现类方法体中存在重复代码：通过 SqlSessionFactory 创建 SqlSession，调用 SqlSession 的数据库操作方法； 调用 sqlSession 的数据库操作方法需要指定 statement 的 id，这里存在硬编码，不得于开发维护； 调用 sqlsession 方法时传入的变量，由于 sqlsession 方法使用泛型，即使变量类型传入错误，在编译阶段也不报错，不利于程序员开发。 Mapper 动态代理开发只需要程序员编写 mapper 接口（就是 dao 接口）； 在编写 mapper.xml（映射文件）和相应的 mapper.java 时需要遵循一个开发规范： mapper.xml 中namespace 就是 mapper.java 的类全路径； mapper.xml 中statement 的 id 和mapper.java 中方法名一致； mapper.xml 中statement 的 parameterType 指定输入参数的类型和 mapper.java 的方法输入参数类型一致； mapper.xml 中 statement 的 resultType 指定输出结果的类型和 mapper.java 的方法返回值类型一致。 输入映射和输出映射输入映射parameterType：指定输入参数类型，可以为简单类型、pojo、hashmap。 MyBatis 通过 OGNL 从输入对象中获取参数值拼接在 sql 中。 对于综合查询，建议 parameterType 使用包装的 pojo，有利于系统扩展。 输出映射MyBatis 将 sql 查询结果的一行记录数据映射为 pojo 对象（一对一），如果有多条数据则分别进行映射，并把对象放到容器 List 中（一对多）。 resultType：查询到的列名和映射的 pojo 的属性名一致时才能映射成功。 reusltMap：如果查询到的列名和映射的 pojo 的属性名不一致时，通过 resultMap 设置列名和属性名之间的映射关系，可以完成映射。 动态sqlif判断 where foreach sql片段","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"原生 JDBC 编程的问题总结","slug":"原生 JDBC 编程的问题总结","date":"2019-06-19T01:13:54.784Z","updated":"2019-06-19T16:22:06.307Z","comments":true,"path":"2019/06/19/原生 JDBC 编程的问题总结/","link":"","permalink":"http://yoursite.com/2019/06/19/原生 JDBC 编程的问题总结/","excerpt":"","text":"本文总结原生 JDBC 编程的一般步骤，总结其存在的问题，并附上典型 JDBC 示例。 原生 JDBC 开发步骤 加载数据库驱动 创建并获取数据库链接 创建 jdbc statement 对象 设置sql语句 设置sql语句中的参数（使用 preparedStatement） 通过 statement 执行 sql 并获取结果 对 sql 执行结果进行解析处理 释放资源（resultSet、preparedstatement、connection） 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class JdbcTest &#123; public static void main(String[] args) &#123; //数据库连接 Connection connection = null; //预编译的Statement，使用预编译的Statement提高数据库性能 PreparedStatement preparedStatement = null; //结果集 ResultSet resultSet = null; try &#123; // 加载数据库驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 数据库连接地址 String URL = &quot;jdbc:mysql://localhost:3306/demo? serverTimezone=GMT&quot;; // 用户名 String USER = &quot;root&quot;; // 密码 String PASSWORD = &quot;root&quot;; // 通过驱动管理类获取数据库链接 Connection conn = DriverManager.getConnection(URL, USER, PASSWORD); // 定义sql语句，&quot;?&quot;表示占位符 String sql = &quot;select * from users where name = ?&quot;; // 获取预处理 statement preparedStatement = connection.prepareStatement(sql); // 设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值 preparedStatement.setString(1, &quot;张三&quot;); // 向数据库发出sql执行查询，查询出结果集 resultSet = preparedStatement.executeQuery(); // 遍历查询结果集 while (resultSet.next()) &#123; System.out.println(resultSet.getString(&quot;id&quot;) + &quot; &quot; + resultSet.getString(&quot;name&quot;)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放资源 if (resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (preparedStatement != null) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 问题总结 数据库连接时，使用时就创建，不使用时就立即释放，对数据库进行频繁地连接和释放，造成数据库资源浪费，从而影响数据库性能。 解决方法：使用数据库连接池管理数据库连接。 将 sql 语句写在 Java 代码中，存在硬编码，如果 sql 语句修改，则需要重新编译 Java 代码，不利于系统维护。 解决方法：将 sql 语句配置在 xml 配置文件中。 使用 preparedStatement 中向占位符号传参数值时，Java 代码中存在硬编码，不利于系统维护。 解决方法：将 sql 语句及占位符号和参数全部配置在 xml 配置文件中。 对结果集解析麻烦，sql 变化导致解析代码变化，且解析前需要遍历，存在硬编码，不利于系统维护。 将查询的结果集，自动映射成 Java 对象。","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://yoursite.com/categories/Web开发/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]}]}